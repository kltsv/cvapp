<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <title>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä–∞—Ñ–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π Dart/Flutter</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
    <link href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css" rel="stylesheet" type="text/css" />
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        #network {
            width: 100%;
            height: 80vh;
            border: 1px solid #ccc;
            margin-top: 20px;
        }

        .file-inputs {
            margin-bottom: 20px;
        }

        .file-inputs label {
            margin-right: 10px;
        }
    </style>
</head>

<body>
    <h2>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä–∞—Ñ–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π Dart/Flutter</h2>
    <div class="file-inputs">
        <label>deps.txt: <input type="file" id="depsFile" accept=".txt"></label>
        <label>deps_status.csv: <input type="file" id="statusFile" accept=".csv"></label>
        <label>–ò—Å–∫–ª—é—á–∏—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é): <input type="text" id="excludeDeps"
                placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä: bloc, http"></label>
        <button id="buildGraph">–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –≥—Ä–∞—Ñ</button>
    </div>
    <div id="network"></div>
    <script>
        let depsText = '', statusCsv = '';
        document.getElementById('depsFile').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (evt) { depsText = evt.target.result; };
                reader.readAsText(file);
            }
        });
        document.getElementById('statusFile').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (evt) { statusCsv = evt.target.result; };
                reader.readAsText(file);
            }
        });
        document.getElementById('buildGraph').onclick = function () {
            if (!depsText) { alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª deps.txt'); return; }
            if (!statusCsv) { alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª deps_status.csv'); return; }
            const depsData = parseDepsTxt(depsText);
            const statusData = parseStatusCsv(statusCsv);
            // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏—Å–∫–ª—é—á–∞–µ–º—ã—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
            const excludeInput = document.getElementById('excludeDeps').value;
            const excludeList = excludeInput.split(',').map(s => s.trim()).filter(Boolean);
            buildGraph(depsData, statusData, excludeList);
        };
        function parseDepsTxt(text) {
            const lines = text.split(/\r?\n/);
            let root = null;
            let section = null;
            const deps = {};
            const edges = [];
            const allDeps = new Set();
            let directDeps = [];
            let devDeps = [];
            // –ù–∞–π–¥—ë–º –∫–æ—Ä–Ω–µ–≤—É—é –±–∏–±–ª–∏–æ—Ç–µ–∫—É (—Ç—Ä–µ—Ç—å—è —Å—Ç—Ä–æ–∫–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä: my_lib 1.0.0)
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim() && !lines[i].startsWith('Dart SDK') && !lines[i].startsWith('Flutter SDK')) {
                    root = lines[i].trim().split(' ')[0];
                    break;
                }
            }
            // –ü–∞—Ä—Å–∏–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                if (line === 'dependencies:') { section = 'dependencies'; continue; }
                if (line === 'dev dependencies:') { section = 'dev dependencies'; continue; }
                if (line === 'transitive dependencies:') { section = 'transitive dependencies'; continue; }
                if (line.startsWith('- ')) {
                    const match = line.match(/^- ([^\s]+) ([^\s]+)(?: \[([^\]]+)\])?/);
                    if (match) {
                        const name = match[1];
                        const version = match[2];
                        const children = match[3] ? match[3].split(/,? /).filter(Boolean) : [];
                        deps[name] = deps[name] || { name, version, children: [] };
                        deps[name].children = children;
                        allDeps.add(name);
                        children.forEach(child => allDeps.add(child));
                        if (section === 'dependencies') directDeps.push(name);
                        if (section === 'dev dependencies') devDeps.push(name);
                    }
                }
            }
            // –î–æ–±–∞–≤–∏–º –∫–æ—Ä–Ω–µ–≤–æ–π —É–∑–µ–ª
            if (root && !deps[root]) {
                deps[root] = { name: root, version: '', children: [] };
                allDeps.add(root);
            }
            // –°–≤—è–∑–∏: –∫–æ—Ä–µ–Ω—å -> —Ç–æ–ª—å–∫–æ –ø—Ä—è–º—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
            directDeps.forEach(dep => edges.push({ from: root, to: dep }));
            devDeps.forEach(dep => edges.push({ from: root, to: dep }));
            // –°–≤—è–∑–∏: –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ -> –∏—Ö children
            Object.values(deps).forEach(dep => {
                dep.children.forEach(child => {
                    edges.push({ from: dep.name, to: child });
                });
            });
            return { root, deps, edges, allDeps: Array.from(allDeps) };
        }
        function parseStatusCsv(csv) {
            const lines = csv.split(/\r?\n/).filter(Boolean);
            const header = lines[0].split(',');
            const map = {};
            for (let i = 1; i < lines.length; i++) {
                const row = lines[i].split(',');
                if (row.length < 2) continue;
                const dep_name = row[0];
                map[dep_name] = {};
                header.forEach((h, idx) => {
                    map[dep_name][h] = row[idx];
                });
            }
            return map;
        }
        function buildGraph(depsData, statusData, excludeList = []) {
            // 1. –í—ã—á–∏—Å–ª—è–µ–º –≥–ª—É–±–∏–Ω—É (—É—Ä–æ–≤–µ–Ω—å) –¥–ª—è –∫–∞–∂–¥–æ–π –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
            const depthMap = {};
            const visited = new Set();
            function bfsLevels(root) {
                const queue = [{ name: root, depth: 0 }];
                while (queue.length) {
                    const { name, depth } = queue.shift();
                    if (visited.has(name)) continue;
                    visited.add(name);
                    depthMap[name] = depth;
                    // –∏—â–µ–º –¥–µ—Ç–µ–π
                    depsData.edges.forEach(edge => {
                        if (edge.from === name && !visited.has(edge.to)) {
                            queue.push({ name: edge.to, depth: depth + 1 });
                        }
                    });
                }
            }
            bfsLevels(depsData.root);

            // 3. –ò—Å–∫–ª—é—á–∞–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –∏ —Ç—Ä–∞–Ω–∑–∏—Ç–∏–≤–Ω–æ –æ—Ç–æ—Ä–≤–∞–Ω–Ω—ã–µ
            const excludeSet = new Set(excludeList);
            // –°—Ç—Ä–æ–∏–º –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ —Ä—ë–±–µ—Ä –±–µ–∑ –∏—Å–∫–ª—é—á—ë–Ω–Ω—ã—Ö
            const filteredEdges = depsData.edges.filter(edge =>
                !excludeSet.has(edge.from) && !excludeSet.has(edge.to)
            );
            // BFS –æ—Ç –∫–æ—Ä–Ω—è –ø–æ –Ω–æ–≤—ã–º —Ä—ë–±—Ä–∞–º, —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ –≤—Å–µ –¥–æ—Å—Ç–∏–∂–∏–º—ã–µ —É–∑–ª—ã
            const reachable = new Set();
            const queue = [depsData.root];
            while (queue.length) {
                const node = queue.shift();
                if (reachable.has(node) || excludeSet.has(node)) continue;
                reachable.add(node);
                filteredEdges.forEach(edge => {
                    if (edge.from === node && !reachable.has(edge.to) && !excludeSet.has(edge.to)) {
                        queue.push(edge.to);
                    }
                });
            }

            // --- –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ —Å–ª–æ—ë–≤ –¥–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã—Ö —Å–≤—è–∑–µ–π ---
            let changed = true;
            while (changed) {
                changed = false;
                depsData.edges.forEach(edge => {
                    if (
                        reachable.has(edge.from) && reachable.has(edge.to) &&
                        depthMap[edge.from] === depthMap[edge.to]
                    ) {
                        // –£–≥–ª—É–±–ª—è–µ–º to –∏ –≤—Å–µ—Ö –µ–≥–æ –ø–æ—Ç–æ–º–∫–æ–≤, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                        const stack = [edge.to];
                        while (stack.length) {
                            const node = stack.pop();
                            if (depthMap[node] <= depthMap[edge.from]) {
                                depthMap[node] = depthMap[edge.from] + 1;
                                changed = true;
                                // –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ—Ö –¥–µ—Ç–µ–π node
                                depsData.edges.forEach(e2 => {
                                    if (e2.from === node && reachable.has(e2.to)) {
                                        stack.push(e2.to);
                                    }
                                });
                            }
                        }
                    }
                });
            }

            // 2. –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —Å–ª–æ—è–º
            const layers = [];
            Object.entries(depthMap).forEach(([name, depth]) => {
                if (!layers[depth]) layers[depth] = [];
                layers[depth].push(name);
            });

            // 4. –ì–æ—Ç–æ–≤–∏–º —É–∑–ª—ã –∏ —Ä—ë–±—Ä–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –¥–æ—Å—Ç–∏–∂–∏–º—ã—Ö
            // --- –ù–æ–≤—ã–π –±–ª–æ–∫: –∏—â–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ outdated —Å—Ä–µ–¥–∏ –¥–æ—Å—Ç–∏–∂–∏–º—ã—Ö ---
            let maxOutdated = 0;
            reachable.forEach(dep => {
                const status = statusData[dep];
                if (status && status.outdated && !isNaN(Number(status.outdated))) {
                    maxOutdated = Math.max(maxOutdated, Number(status.outdated));
                }
            });
            // ---
            const nodes = [];
            const edges = [];
            const RADIUS_STEP = 350;
            const CENTER_X = 0, CENTER_Y = 0;
            // –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–ª–æ—è –≤—ã—á–∏—Å–ª—è–µ–º —É–≥–ª—ã
            const nodeAngles = {};
            // –ü–µ—Ä–≤—ã–π —Å–ª–æ–π (–∫–æ—Ä–µ–Ω—å) ‚Äî –≤ —Ü–µ–Ω—Ç—Ä–µ
            if (layers[0] && layers[0].length === 1) {
                nodeAngles[layers[0][0]] = 0;
            }
            // –ü–µ—Ä–≤—ã–π —Ä–∞–¥–∏–∞–ª—å–Ω—ã–π —Å–ª–æ–π (–ø—Ä—è–º—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏) ‚Äî —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ
            if (layers[1]) {
                const count = layers[1].length;
                layers[1].forEach((dep, i) => {
                    nodeAngles[dep] = (2 * Math.PI * i) / count;
                });
            }
            // –û—Å—Ç–∞–ª—å–Ω—ã–µ —Å–ª–æ–∏ ‚Äî –ø–æ —Å—Ä–µ–¥–Ω–µ–º—É —É–≥–ª—É —Ä–æ–¥–∏—Ç–µ–ª–µ–π
            for (let depth = 2; depth < layers.length; depth++) {
                const prevLayer = layers[depth - 1];
                const prevSet = new Set(prevLayer);
                // –î–ª—è –∫–∞–∂–¥–æ–≥–æ —É–∑–ª–∞ –∏—â–µ–º —Ä–æ–¥–∏—Ç–µ–ª–µ–π –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–º —Å–ª–æ–µ
                const angleList = [];
                layers[depth].forEach(dep => {
                    // –†–æ–¥–∏—Ç–µ–ª–∏ ‚Äî —Ç–µ, —É –∫–æ–≥–æ –µ—Å—Ç—å —Ä–µ–±—Ä–æ dep -> —ç—Ç–æ—Ç dep
                    const parents = depsData.edges.filter(e => e.to === dep && prevSet.has(e.from)).map(e => e.from);
                    if (parents.length === 0) {
                        angleList.push({ dep, angle: 0 });
                        return;
                    }
                    // –°—Ä–µ–¥–Ω–∏–π —É–≥–æ–ª —Ä–æ–¥–∏—Ç–µ–ª–µ–π
                    let sumSin = 0, sumCos = 0;
                    parents.forEach(p => {
                        const a = nodeAngles[p] ?? 0;
                        sumSin += Math.sin(a);
                        sumCos += Math.cos(a);
                    });
                    const avgAngle = Math.atan2(sumSin / parents.length, sumCos / parents.length);
                    // atan2 –º–æ–∂–µ—Ç –≤–µ—Ä–Ω—É—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π —É–≥–æ–ª, –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º
                    const normAngle = (avgAngle + 2 * Math.PI) % (2 * Math.PI);
                    angleList.push({ dep, angle: normAngle });
                });
                // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å—Ä–µ–¥–Ω–µ–º—É —É–≥–ª—É
                angleList.sort((a, b) => a.angle - b.angle);
                // --- –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —É–≥–æ–ª –º–µ–∂–¥—É —É–∑–ª–∞–º–∏ ---
                const minAngle = 0.12; // ~7 –≥—Ä–∞–¥—É—Å–æ–≤
                for (let i = 1; i < angleList.length; i++) {
                    if (angleList[i].angle - angleList[i-1].angle < minAngle) {
                        angleList[i].angle = angleList[i-1].angle + minAngle;
                    }
                }
                // –ï—Å–ª–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π –∏ –ø–µ—Ä–≤—ã–π —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ (–ø–æ –∫—Ä—É–≥—É), —á—É—Ç—å —Ä–∞–∑–¥–≤–∏–Ω—É—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π
                if (angleList.length > 1 && (angleList[0].angle + 2 * Math.PI - angleList[angleList.length-1].angle) < minAngle) {
                    angleList[angleList.length-1].angle = angleList[0].angle - 2 * Math.PI + minAngle;
                }
                // –†–∞—Å—Å—Ç–∞–≤–ª—è–µ–º –ø–æ –∫—Ä—É–≥—É –≤ —ç—Ç–æ–º –ø–æ—Ä—è–¥–∫–µ
                const count = angleList.length;
                angleList.forEach((item, i) => {
                    // –ß—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –Ω–∞–ª–æ–∂–µ–Ω–∏—è, —á—É—Ç—å —Ä–∞–∑–¥–≤–∏–≥–∞–µ–º –≤–æ–∫—Ä—É–≥ —Å—Ä–µ–¥–Ω–µ–≥–æ —É–≥–ª–∞
                    const spread = Math.PI / count; // –Ω–µ–±–æ–ª—å—à–æ–π —Ä–∞–∑–±—Ä–æ—Å
                    const angle = item.angle + (i - count / 2) * (spread / count);
                    nodeAngles[item.dep] = angle;
                });
            }
            // –¢–µ–ø–µ—Ä—å —Ä–∞–∑–º–µ—â–∞–µ–º —É–∑–ª—ã –ø–æ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—ã–º —É–≥–ª–∞–º
            layers.forEach((layer, depth) => {
                // –¢–æ–ª—å–∫–æ –¥–æ—Å—Ç–∏–∂–∏–º—ã–µ –∏ –Ω–µ –∏—Å–∫–ª—é—á—ë–Ω–Ω—ã–µ
                const filteredLayer = layer.filter(dep => reachable.has(dep) && !excludeSet.has(dep));
                const radius = depth * RADIUS_STEP;
                filteredLayer.forEach(dep => {
                    const angle = nodeAngles[dep] ?? 0;
                    const x = depth === 0 ? CENTER_X : Math.round(CENTER_X + radius * Math.cos(angle));
                    const y = depth === 0 ? CENTER_Y : Math.round(CENTER_Y + radius * Math.sin(angle));
                    const status = statusData[dep];
                    let emoji = '';
                    if (status && status.latest_version_published) {
                        const dateStr = status.latest_version_published.replace(/\./g, '-');
                        const date = new Date(dateStr);

                        if (!isNaN(date.getTime())) {
                            const now = new Date();
                            const diffMonths = (now.getFullYear() - date.getFullYear()) * 12 + (now.getMonth() - date.getMonth());
                            if (diffMonths >= 24) {
                                emoji = `üî¥`;
                            } else if (diffMonths >= 12) {
                                emoji = `üü†`;
                            } else if (diffMonths >= 6) {
                                emoji = `üü°`;
                            }
                        }
                    }
                    let label = `<b>${dep}</b> ${emoji}`;
                    if (status) {
                        label += `\n–ª–æ–∫–∞–ª—å–Ω–∞—è: ${status.dep_local_version || ''}`;
                        if (status.dep_latest_version) label += `\n–ø–æ—Å–ª–µ–¥–Ω—è—è: ${status.dep_latest_version}`;
                        if (status.outdated) label += `\n—É—Å—Ç–∞—Ä–µ–ª–∞: ${status.outdated}`;
                        if (status.latest_version_published) label += `\n–æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ: ${status.latest_version_published}`;
                    }
                    // ---
                    // --- –¶–≤–µ—Ç–æ–≤–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ ---
                    let color = undefined;
                    if (dep === depsData.root) {
                        color = { background: '#e3f2fd', border: '#1976d2', highlight: { background: '#e3f2fd', border: '#1976d2' }, hover: { background: '#e3f2fd', border: '#1976d2' } };
                    } else if (status && status.outdated && !isNaN(Number(status.outdated)) && maxOutdated > 0 && Number(status.outdated) > 0) {
                        // –ì—Ä–∞–¥–∏–µ–Ω—Ç –æ—Ç #e3f2fd (min, —Å–∏–Ω–∏–π) –¥–æ #b71c1c (max, –∫—Ä–∞—Å–Ω—ã–π)
                        const minColor = [227, 242, 253]; // #e3f2fd
                        const maxColor = [183, 28, 28];   // #b71c1c
                        const ratio = Math.min(1, Number(status.outdated) / maxOutdated);
                        const r = Math.round(minColor[0] + (maxColor[0] - minColor[0]) * ratio);
                        const g = Math.round(minColor[1] + (maxColor[1] - minColor[1]) * ratio);
                        const b = Math.round(minColor[2] + (maxColor[2] - minColor[2]) * ratio);
                        const bg = `rgb(${r},${g},${b})`;
                        color = {
                            background: bg, border: '#b71c1c',
                            highlight: { background: bg, border: '#b71c1c' },
                            hover: { background: bg, border: '#b71c1c' }
                        };
                    } else {
                        color = { background: '#e3f2fd', border: '#1976d2', highlight: { background: '#e3f2fd', border: '#1976d2' }, hover: { background: '#e3f2fd', border: '#1976d2' } };
                    }
                    // ---
                    nodes.push({
                        id: dep,
                        label,
                        shape: 'box',
                        color,
                        font: { multi: 'html', size: 14, bold: dep === depsData.root },
                        borderWidth: dep === depsData.root ? 3 : 1,
                        group: dep === depsData.root ? 'root' : undefined,
                        x, y, fixed: true
                    });
                });
            });
            // –†—ë–±—Ä–∞ —Ç–æ–ª—å–∫–æ –º–µ–∂–¥—É –¥–æ—Å—Ç–∏–∂–∏–º—ã–º–∏ –∏ –Ω–µ –∏—Å–∫–ª—é—á—ë–Ω–Ω—ã–º–∏
            filteredEdges.forEach(edge => {
                if (reachable.has(edge.from) && reachable.has(edge.to)) {
                    edges.push({ from: edge.from, to: edge.to, arrows: 'to' });
                }
            });
            const container = document.getElementById('network');
            container.innerHTML = '';
            const data = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };
            const options = {
                physics: false,
                nodes: {
                    shape: 'box',
                    margin: 10,
                    font: { multi: 'html', size: 14 },
                },
                edges: {
                    arrows: 'to',
                    smooth: { type: 'dynamic' },
                },
                groups: {
                    root: {
                        color: { background: '#e3f2fd', border: '#1976d2' },
                        borderWidth: 3,
                    }
                }
            };
            new vis.Network(container, data, options);
        }
    </script>
</body>

</html>